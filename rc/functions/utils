#!/bin/bash
#########################################################
# 							#
# This is BashStyle-NG					#
#							#
# Licensed under GNU GENERAL PUBLIC LICENSE v3    	#
#							#
# Copyright 2007 - 2010 Christopher Bratusek		#
#							#
#########################################################

xunalias() {

	for alias in $@; do
		[[ $(alias | grep -w $alias=) != "" ]] &&
			{ unalias $alias ; }
	done

}

xmv() {

	if [[ $# -lt 2 ]]; then
		echo "not enough arguements"
		exit 0
	fi

	destination="${!#}"

	if [[ ! -e "$destination" ]]; then
		mkdir -p "$destination"
	fi

	for file in "$@"; do
		if [[ ! "$file" == "$destination" ]]; then
			mv -v "$file" "$destination"
		fi
	done

}

xdel() {

	shopt -s globstar

	[[ "$@" != "" ]] &&
		{ for argv in "$@"; do
			rm -fv ./**/*"$argv"
		done }

}

xcp() {

	if [[ $# -lt 2 ]]; then
		echo "not enough arguements"
		exit 0
	fi

	destination="${!#}"

	set -- "$destination" "$@"

	if [[ ! -e "$destination" ]]; then
		mkdir -p "$destination"
	fi

	for file in "$@"; do
		if [[ ! "$file" == "$destination" ]]; then
			cp -v "$file" "$destination"
		fi
	done

}

trunc_pwd ()
{

	case $1 in
		*help )
			echo -e "\n${ewhite}Usage:\n"
			echo -e "${eorange}trunc_pwd ${ewhite}|${egreen} ! no options !\n"
			tput sgr0
		;;

		* )
			export BSNG_GCONF_READ=1

			pwdmaxlen=$(get_key pwdmaxlength)
			trunc_symbol=$(get_key pwdchar)
			dirchar=$(get_key dirchar)

			newsepacolor=$(echo $sepacolor | sed -e 's/\\\[//g' -e 's/\\\]//g')
			newwdircolor=$(echo $wdircolor | sed -e 's/\\\[//g' -e 's/\\\]//g')
			newpscoloror=$(echo $pscolor | sed -e 's/\\\[//g' -e 's/\\\]//g')

			if [ ${#PWD} -gt $pwdmaxlen ]; then
				pwdoffset=$(( ${#PWD} - $pwdmaxlen ))
				if [[ $pstyle_supported == true ]]; then
					xPWD="$newpscoloror${trunc_symbol}${PWD:$pwdoffset:$pwdmaxlen}"
				else	xPWD="${trunc_symbol}${PWD:$pwdoffset:$pwdmaxlen}"
				fi
				if [[ $enabcol == true && $pstyle_supported == true ]]; then
					newPWD="${xPWD//\//$newsepacolor$dirchar$newwdircolor}"
				else	newPWD="${xPWD//\//$dirchar}"
				fi
			else
				if [[ $enabcol == true && $pstyle_supported == true ]]; then
				newPWD="${PWD//\//$newsepacolor$dirchar$newwdircolor}"
			else	newPWD="${PWD//\//$dirchar}"
			fi
			fi

			echo -e $newPWD
			unset BSNG_GCONF_READ
		;;
	esac

}

up () {

[ "${1/[^0-9]/}" == "$1" ] && {
        local ups=""
        for ((i=1; i<=$1; i++))
        do
                ups=$ups"../"
        done
        cd $ups
        }

}

empty () {

	find "$1" -empty

}

deadlink () {

	find -L -type l
}

bookmark () {

	if [[ $1 != "" && $(alias | grep -w go-$1) == "" ]]; then
		echo "alias go-$1='cd $PWD'" >> $HOME/.bookmarks
		. $HOME/.bookmarks
	elif [[ $1 == "" ]]; then
		echo "need name for the bookmark."
	else	echo "bookmark go-$1 already exists."
	fi

}

unmark () {

	if [[ $(alias | grep -w go-$1= ) != "" ]]; then
		sed -e "/go-$1/d" -i $HOME/.bookmarks
		xunalias go-$1
	fi

}

man2pdf ()
{

	case $1 in
		*help | "" )
			echo -e "\n${ewhite}Usage:"
			echo -e	"\n${eorange}man2pdf${ewhite} |${egreen} <manualpage>${eiceblue} [generate a pdf from <manualpage>]\n"
			tput sgr0
		;;

		* )
			check_opt ps2pdf man2pdf
			if [[ $1 != "" ]]; then
				man -t $1 | ps2pdf - >$1.pdf
			fi
		;;
	esac

}

exchange()
{
	typeset temp
	SAVE=$IFS
	IFS=''
	eval $(echo "temp=\"\$$1\"")
	eval $(echo "$1=\"\$$2\"")
	eval $(echo "$2=\"$temp\"")
	IFS=$SAVE
}

swap()
{

	if [[ $1 && $2 ]]; then
		mv "$1" temp.$$
		mv "$2" "$1"
		mv temp.$$ "$2"
	fi

}

progressbar()
{

	SP_COLOUR="\e[37;44m"
	SP_WIDTH=5.5
	SP_DELAY=0.2
	SP_STRING=${2:-"'|/=\'"}

	while [ -d /proc/$1 ]
	do
		printf "$SP_COLOUR\e7  %${SP_WIDTH}s  \e8\e[01;37m" "$SP_STRING"
		sleep ${SP_DELAY:-.2}
		SP_STRING=${SP_STRING#"${SP_STRING%?}"}${SP_STRING%?}
	done

	tput sgr0

}

spinner()
{

	PROC=$1
	while [ -d /proc/$PROC ];do
		echo -ne '\e[01;32m/\x08' ; sleep 0.05
		echo -ne '\e[01;32m-\x08' ; sleep 0.05
		echo -ne '\e[01;32m\\\x08' ; sleep 0.05
		echo -ne '\e[01;32m|\x08' ; sleep 0.05
	done

}


spanner(){

	PROC=$1;COUNT=0
	echo -n "Please wait "
	while [ -d /proc/$PROC ];do
		while [ "$COUNT" -lt 10 ];do
			echo -ne '\x08  ' ; sleep 0.1
			((COUNT++))
		done
		until [ "$COUNT" -eq 0 ];do
			echo -ne '\x08\x08 ' ; sleep 0.1
			((COUNT -= 1))
		done
	done

}

clock ()
{
	while true; do
		clear;
		echo "===========";
		date +"%r";
		echo "===========";
		sleep 1;
	done
}
